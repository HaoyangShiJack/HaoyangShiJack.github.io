---
title: ECE314
author: Haoyang
date: 2025-09-1
layout: post
mermaid: true
---
👨‍🎓：The score is made through two parts, labs+quizzes, 80% + 20% (no tests)

# Lab 🧪

## Lab 0:
### 学习内容

#### 1. 介绍python所需要用的库：
```python
%matplotlib inline
import matplotlib.pyplot as plt
import matplotlib.image as img
import numpy as np
import scipy as sp
import scipy.stats as st
```

#### 2. 区分 tuples 和 lists

```python

##list correct output
x = [1,2,3,4,5]
y = [6,7,8,9,10]
print (x, y)
x[0] = 'Dog'
print (x[0]) 

##tuple syntax error
x = (1,2,3,4,5)
y = (6,7,8,9,10)
print (x, y)
x[0] = 'Dog'
print (x[0]) 
```


#### 3. python 从第0个开始记录

$a_{13}$ = `a[0][2]`


#### 4. numpy的array使用法
Input:
```python
x = np.array([[1,2,3],[4,5,6],[7,8,9]])
print (x)
print (x[0,0])
print (x[:,1])
print (x[1,:])
```
output:
```bash
[[1 2 3]
 [4 5 6]
 [7 8 9]]
1
[2 5 8]
[4 5 6]
```
#### 5. 画图像
```python
def f(t): #Creates the function that we are going to plot
    return t**3-t**2+t-1

t = np.linspace(-10,10,1000) #Creates an array from -10 to 10 with 1000 points in it
plt.plot(t,f(t)) #Generates a plot of these two vectors.
plt.title('Function vs. Time')
plt.xlabel('Time(s)')
plt.ylabel('Function Value')
```
![My page](assets/imgs/image.png)

#### 6.Numpy 的矩阵用法


```python
A = np.array([(3,7,9),(4,5,1),(12,6,3)]) #Creates Matrix A
B = np.array([(1,0,3),(2,4,0),(8,3,1)]) #Creates Matrix B
A_transpose = A.T #Takes the transpose of A
C = A_transpose.dot(B) #Takes the matrix multiplication of A_transpose and B. Note using * performs a different operation on 2-d arrays
                       # * is the usual matrix multiplication when applied to np.matrix objects
print (np.linalg.eigvals(C)) #Uses the eigvals method under linalg under NumPy to print the eigenvalues
```

### 总结

python在ECE313的基本用法

## Lab 1

### 学习的内容

#### 1.集合的定义
```python

p = 1./4 #Sets the probability, uses decimal to create double (not integer)
# Define the sample space and two events
Omega = {1, 2, 3, 4, 5, 6}
A = {1, 2, 3}
E = {2, 4, 6}
```
#### 2.集合的一系列运算
```python
# Calculate the union (A U E)
union_AE = A.union(E)
print(f"A U E = {union_AE}")

# Calculate the intersection (A ∩ E)
intersection_AE = A.intersection(E)
print(f"A ∩ E = {intersection_AE}")

# Calculate the complement (A^c)
complement_A = Omega.difference(A)
print(f"A^c = {complement_A}")

```
#### 3.集合的应用
```python
print(f"E^c={Omega.difference(E)}")
print(f"(A U E)^c={Omega.difference(union_AE)}")
```
#### 4.fprint
```python
print(f"P(E) = {E_size}/{Omega_size} = {prob_E}")
```
### 总结
集合应用，考察A.union(B), A.difference(B),A.intersection(B)


## Lab 2
### 学习内容

### 总结

## Lab 3
### 学习内容
##### 1. scipy.stats

```python
import scipy as sp
import scipy.stats as st
## 对于p=1/4，定一个伯努利试验
p = 1./4 #Sets the probability, uses decimal to create double (not integer)
bernoulli25 = st.bernoulli(p) #Generates object for Bernoulli(0.25) distribution
x = np.linspace(-4,4,1001) #Generates a vector on [-4,4] with 1001 points in it
## 画图
plt.plot(x,bernoulli25.cdf(x))  #Creates a graph of the cumulative distribution fucntion (CDF)  of X
plt.title('CDF of Bernoulli(0.25) distribution')
plt.axis([-4, 4, 0, 1.05]) #Sets bounds on the plot axis
```

```shell
Mean: 0.25
Var: 0.1875
```

![My page](assets/imgs/output2.png)


#### 2. Exercise 1
Above, we were able to create our Bernoulli distribution through scipy.stats. 
<br><br>**<SPAN style="BACKGROUND-COLOR: #8190deff">Problem 1:</SPAN>** Using the scipy.stats package do the following:
<html>
    <body>
        <ol>
            <li> Print the mean and standard deviation of a Bernoulli variable where $p=\frac{14}{17}.$  [Tip: If you type the name of an object followed by a period, such as bernoulli25.  in a code cell and then press the tab key, a list of methods for that object is displayed.]</li>
            <li> Create a graph of the cumulative distribution function (CDF).  Try adapting the code in the previous cell to plot the CDF.  What happens if you change np.linspace(-5,5,1001) to np.linspace(-5,5,1000)? Can you explain why?
            </li>
        </ol>
    </body>
</html>

Answer: 

```python
p=14/17
bernoulli1417=st.bernoulli(p)
print("Mean:",bernoulli1417.mean())
print("Standard Deviation:",bernoulli1417.std())

x = np.linspace(-5,5,1001) 
plt.plot(x,bernoulli1417.cdf(x))  
plt.title('CDF of Bernoulli(0.25) distribution')
plt.axis([-4, 4, 0, 1.05])  
```


#### 3. rv_discrete

处理discrete variable 有一系列的方法，其中最重要的就是

<br><br>**<SPAN style="BACKGROUND-COLOR: #8190deff">Problem 2:</SPAN>** Consider the random variable $X$ representing the sum of the outcomes when rolling two fair six-sided dice. For example, if you roll a 2 and a 5, the sum is 7.

<html>
    <body>
        <ol>
            <li>First, determine the vector of possible values, $c$, that the sum $X$ can take. Then, determine the corresponding vector of probabilities, $p$. <b>Hint:</b> There are 36 total possible outcomes when rolling two dice. The probability of rolling a sum of 2 is 1/36, a sum of 3 is 2/36, and so on.</li>
            <li>Create your own discrete random variable object to represent the sum of two dice rolls using your calculated $c$ and $p$ vectors.</li>
            <li>Print out the mean (also known as the expected value) of this distribution.</li>
            <li>Graph the pmf and CDF of this distribution.</li>
        </ol>
    </body>
</html>


```python
#step 1
p=(1/36,2/36,3/36,4/36,5/36,6/36,5/36,4/36,3/36,2/36,1/36)
c=(2,3,4,5,6,7,8,9,10,11,12)


#step2
Xsum = st.rv_discrete(values=(c,p))
print ('Mean:', Xsum.mean())
print ('Var:', Xsum.var())
plt.plot(c,Xsum.pmf(c),'o') #Plots the pmf. The 'o' indicates to plot the points discretely as circles
plt.title('pmf of Xsum')
plt.figure() #Let us be able to plot another graph below the first
n = np.linspace(0,15,1000)
plt.plot(n,Xsum.cdf(n))
plt.title('CDF of Xsum')
```



### 总结

## Lab 4
### 学习内容
#### 1.Binomial Distribution
```python
import scipy.stats as st
n=5,p=0.5
my_binom=st.binom(n,p)#这里的n,p都是先声明好的变量
                     #调用的是binom函数
```
此时就已经创造好了一个二项分布的对象，基于这个可以创造出多个`my_binom`的一系列性质，例如：

```python
my_binom.pdf(k)##这一点的概率分布
my_binom.cdf(k)##这一点P(X<=k) Cumulative Distribution function,累积分布函数
my_binom.mean() ###平均数
my_binom.var()  ### 方差
my_binom.rvs(size=10)
```

**<SPAN style="BACKGROUND-COLOR: #C0C0C0">Example_Problem 1:</SPAN>** I'm going to roll a standard die 20 times and count how many times I roll a 4,5 or 6.

<html>
    <body>
        <ol>
            <li> Using the st.binom object, create a specialized object my_binom1 for the distribution by freezing n and p to appropriate values. </li>
            <li> Using the formula for Binomial distribution above and the class st.rv_discrete, create your own specialized <strong>object </strong> my_binom2 that represents the same distribution. (Hint: The whole point of this problem is to build up an object that behaves that same as the one produced by st.binom in (1) <I>without relying on st.binom at all.</I> You need to determine your own c and p vectors.) </li>
            <li> Print the probability that you roll a 4, 5, or 6 an even number of times out of the 20 rolls. Do this calculation using my_binom1 and then again using my_binom2 with the .pmf() function.
            Do your calculations agree?</li>
        </ol>
    </body>
</html>

```python
########Student Answer##############
#1
#### Method 1: use the st.binom object #####
n=20
p=1./2
my_binom1=st.binom(n,p)



#2
###### Method 2: custom the values and corresponding probabilities of the rv ######

p_values = []

for k in range(0,n+1):
    probability = nchoosek(n,k) * (p**k) * ((1-p)**(n-k))
    p_values.append(probability)
my_binom2 = st.rv_discrete(values=(range(0,n+1), p_values))
print(my_binom2.rvs(size=10))
def factorial(n):
    
    # Input: integer n 
    # Output: n!

    assert n>=0
    fact=1
    for i in range(1,n+1):
        fact=fact*i

    return fact
def nchoosek(n,k):
    # Input: integer n, integer k, where 0 <= k <= n.
    # Output: the number of ways to choose k balls from n distinct balls.
    return factorial(n)/(factorial(n-k)*factorial(k))




#3
### Final Check
probability_sum1 = 0
probability_sum2 = 0

for k in range(0, n + 1, 2):
    probability_sum1 += my_binom1.pmf(k) 
    probability_sum2 += my_binom2.pmf(k) 

print(f"my_binom1's even numbers' probability: {probability_sum1}")
print(f"my_binom2's even numbers' probability: {probability_sum2}")

if np.isclose(probability_sum1, probability_sum2):
    print("Same")
else:
    print("Different")
```



#### 2.Geometry Distribution
<br><br>**<SPAN style="BACKGROUND-COLOR: #C0C0C0">Problem 2:</SPAN>**
An engineer is testing a new type of CPU chip. According to manufacturing standards, the probability that any given chip is defective is `p = 0.5`. The engineer will continue to test new chips until the first defective one is found.

1.  What is the probability that the engineer finds the first defective chip on the 6th test?
2.  On average, how many chips should the engineer expect to test to find the first defective one?
3.  What is the probability that the first defective chip is found within the first 10 tests (inclusive)?


```python
p=0.5
n=2
cpu_standard=st.geom(p)
print(cpu_standard.pmf(n))

#2
print(cpu_standard.mean())

#3
print(cpu_standard.cdf(10))

```
#### 3.Poisson Distribution
the Poisson distribution has only one single parameter $\lambda$ and a probability mass function given by: $p(k) = \frac{e^{-\lambda}\lambda^k}{k!}$ for $k\geq 0.$ The parameter $\lambda$ represents a mean such as the number of hits of a website in one minute, or the number of mispelled words in a document. Thus $p(k)$ represents the probability the number of events occuring is $k$ given that the average number events that occur is $\lambda$.(==$P(k)$可以通俗的认为就是在一时间里来公交车的概率，例如告诉每一小时有两辆大巴，那么如果把1个小时当作单位，那么$\lambda=2$==，所以公式也可以看作是$P_t(k)= \frac{e^{-\lambda t}(\lambda t) ^k}{k!}$) 当 $n$ is large, $p$ is small, and $np \approx \lambda$.

##### Example 
]泊松分布被广泛使用，因为它在 $n$ 较大、$p$ 较小且 $np \approx \lambda$ 的情况下是二项分布的良好近似。它比二项分布更简单，只有一个参数，且不涉及二项式系数。假设你创建了一个网站，==平均每天的访问次数为 1200 次==。这可以看作是一个泊松分布的情况，其中==λ = 1200==，但我们也可以将其建模为二项分布。如果我们将一天细分为每一分钟的单位，那么在任何特定的一分钟内发生一次击中的概率为 ==$p = \frac{1200}{24*60} = \frac{5}{6}$==，而一天中有 $n = 24*60 = 1440$ 分钟。下面是这个泊松分布的二项式近似图。

```python
lamb =1200 #Average number of hits per day
n = 60*24. #Number of minutes in a day
p = lamb/n #Probability of a hit occuring in a minute
print ('p =', p)

k = range(2*lamb)
plt.plot(k,st.binom.pmf(k,n,p), 'b', label = 'Binomial')
plt.plot(k,st.poisson.pmf(k,lamb), 'r', label = 'Poisson')
plt.title('PMF of Hits Per Day')
plt.legend()

x = np.linspace(0,2*lamb,10000)
plt.figure()
plt.plot(x,st.binom.cdf(x,n,p), 'b', label = 'Binomial')
plt.plot(x,st.poisson.cdf(x,lamb), 'r', label = 'Poisson')
plt.ylim(0,1.2)
plt.title('CDF of Hits Per Day')
plt.legend()
```
The output:

![My page](assets/imgs/output.png)
![My page](assets/imgs/output1.png)


**<SPAN style="BACKGROUND-COLOR: #C0C0C0">Problem 3:</SPAN>** While working on a new research project, I have a probability of 𝑝=.017 of successfully analyzing a dataset during any given minute. Suppose there are 340 datasets that need to be analyzed, and I have 10 weeks to complete the project (assuming I work 35 hours per week). What's the probability that I will complete the project before the deadline? Equivalently, what is the probability that I analyze at least 340 datasets? To answer this question, do the following:
<html>
    <body>
        <ol>
            <li> Create a binomial variable X to represent the number of datasets I analyze (for this and other parts of the
            problem, assume I keep working at the same rate if I finish analyzing 340 datasets).</li>
            <li> Create a Poisson variable Y to represent the same number, using the Poisson approximation.
            Make sure to print out what $\lambda$ is.</li>
            <li> Find the probability of my success (i.e. analyzing at least 340 datasets) using the CDFs of each RV. Do they agree?</li>
            <li> Find the probability that I analyze exactly 340 datasets using the pmf of each RV.  Do they agree? </li>
        </ol>
    </body>
</html>

```python
#1
n=35*10*60
p=0.017
X = st.binom(n,p)

#2
lambd=n*p
Y = st.poisson(lambd)
print("lambda=",lambd)


#3
print(f"X is {1-X.cdf(339)}")
print(f"Y is {1-Y.cdf(339)}")
print("They agree")

#4
print(f"X is {X.pmf(340)}")
print(f"Y is {Y.pmf(340)}")
print("They  agree")
```
output
```shell
lambda= 357.0
X is 0.8246311033298527
Y is 0.8225239027696181
They agree
X is 0.01435241251396396
Y is 0.01433572475685986
They agree
```
### 总结
三个discrete分布的应用
## Lab 5
### 学习内容
#### 1. 模拟Bernouli 随机变量的过程
```python
cp = 1./7 #Probability（概率大小）
T = 30 #Number of time steps （模拟次数）
X = []  #建造列表
for i in range(1,T+1):   #range(1,T+1) is the list of numbers 1 through T
    X.append(st.bernoulli.rvs(p)) #Fills the list with Bernoulli(p) variates
## 遍历坐标上从1~T+1，然后随机以$\frac{1}{7}$ 经行分配

plt.plot(range(1,T+1),X, 'o')
plt.title('Sample Path of Bernoulli process with p=1/7')
plt.ylim((0,2))
plt.ylabel(r'$X(\omega)$') #You can use LaTex in the Python ode
plt.xlabel('Time')
```

Output:
![My page](assets/imgs/output3.png)

#### 2. np.arrange()和 np.linspace的区别
1. np.arange() (arrange = a range): **侧重于步长 (step size)**。你告诉它“从哪里开始，到哪里结束，每一步走多远”。

2. np.linspace() (linspace = linear space): **侧重于点的数量** (number of points)。你告诉它“从哪里开始，到哪里结束，总共给我切分成多少个点”。

```python
# 1. np.arange (步长为 1)
# 得到 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
# 注意：不包括 10
arr_arange1 = np.arange(0, 10)

# 2. np.linspace(根据点的个数来取步长)
arr_arrange2 = np.linspace(0,10,5)
# 步长的计算方式： (10-0)/(5-1) => 植树问题
```

### 总结
# Quiz 💯

## Quiz 1
考察了什么是sample space, A.intersection(B) , 其余都是ECE313的很基础内容

## Quiz 2
考察了一部分正太分布和二项分布，主要是条件概率的应用：$P(A|B)\cdot P(B)=P(B|A)\cdot P(A)$
Line A :



---
title: ECE314
author: Haoyang
date: 2025-09-1
layout: post
mermaid: true
---
👨‍🎓：The score is made through two parts, labs+quizzes, 80% + 20% (no tests)

# Lab 🧪

## Lab 0:
### 学习内容

#### 1. 介绍python所需要用的库：
```python
%matplotlib inline
import matplotlib.pyplot as plt
import matplotlib.image as img
import numpy as np
import scipy as sp
import scipy.stats as st
```

#### 2. 区分 tuples 和 lists

```python

##list correct output
x = [1,2,3,4,5]
y = [6,7,8,9,10]
print (x, y)
x[0] = 'Dog'
print (x[0]) 

##tuple syntax error
x = (1,2,3,4,5)
y = (6,7,8,9,10)
print (x, y)
x[0] = 'Dog'
print (x[0]) 
```


#### 3. python 从第0个开始记录

$a_{13}$ = `a[0][2]`


#### 4. numpy的array使用法
Input:
```python
x = np.array([[1,2,3],[4,5,6],[7,8,9]])
print (x)
print (x[0,0])
print (x[:,1])
print (x[1,:])
```
output:
```bash
[[1 2 3]
 [4 5 6]
 [7 8 9]]
1
[2 5 8]
[4 5 6]
```
#### 5. 画图像
```python
def f(t): #Creates the function that we are going to plot
    return t**3-t**2+t-1

t = np.linspace(-10,10,1000) #Creates an array from -10 to 10 with 1000 points in it
plt.plot(t,f(t)) #Generates a plot of these two vectors.
plt.title('Function vs. Time')
plt.xlabel('Time(s)')
plt.ylabel('Function Value')
```
![My page](assets/imgs/image.png)

#### 6.Numpy 的矩阵用法


```python
A = np.array([(3,7,9),(4,5,1),(12,6,3)]) #Creates Matrix A
B = np.array([(1,0,3),(2,4,0),(8,3,1)]) #Creates Matrix B
A_transpose = A.T #Takes the transpose of A
C = A_transpose.dot(B) #Takes the matrix multiplication of A_transpose and B. Note using * performs a different operation on 2-d arrays
                       # * is the usual matrix multiplication when applied to np.matrix objects
print (np.linalg.eigvals(C)) #Uses the eigvals method under linalg under NumPy to print the eigenvalues
```

### 总结

python在ECE313的基本用法

## Lab 1

### 学习的内容

#### 1.集合的定义
```python

p = 1./4 #Sets the probability, uses decimal to create double (not integer)
# Define the sample space and two events
Omega = {1, 2, 3, 4, 5, 6}
A = {1, 2, 3}
E = {2, 4, 6}
```
#### 2.集合的一系列运算
```python
# Calculate the union (A U E)
union_AE = A.union(E)
print(f"A U E = {union_AE}")

# Calculate the intersection (A ∩ E)
intersection_AE = A.intersection(E)
print(f"A ∩ E = {intersection_AE}")

# Calculate the complement (A^c)
complement_A = Omega.difference(A)
print(f"A^c = {complement_A}")

```
#### 3.集合的应用
```python
print(f"E^c={Omega.difference(E)}")
print(f"(A U E)^c={Omega.difference(union_AE)}")
```
#### 4.fprint
```python
print(f"P(E) = {E_size}/{Omega_size} = {prob_E}")
```
### 总结
集合应用，考察A.union(B), A.difference(B),A.intersection(B)


## Lab 2
### 学习内容

### 总结

## Lab 3
### 学习内容

### 总结

## Lab 4
### 学习内容
#### 1.Binomial Distribution
```python
import scipy.stats as st
n=5,p=0.5
my_binom=st.binom(n,p)#这里的n,p都是先声明好的变量
                     #调用的是binom函数
```
此时就已经创造好了一个二项分布的对象，基于这个可以创造出多个`my_binom`的一系列性质，例如：
```python
my_binom.pdf(k)##这一点的概率分布
my_binom.cdf(k)##这一点P(X<=k) Cumulative Distribution function,累积分布函数
my_binom.mean() ###平均数
my_binom.var()  ### 方差
my_binom.rvs(size=10)
```
**<SPAN style="BACKGROUND-COLOR: #C0C0C0">Example_Problem 1:</SPAN>** I'm going to roll a standard die 20 times and count how many times I roll a 4,5 or 6.

<html>
    <body>
        <ol>
            <li> Using the st.binom object, create a specialized object my_binom1 for the distribution by freezing n and p to appropriate values. </li>
            <li> Using the formula for Binomial distribution above and the class st.rv_discrete, create your own specialized <strong>object </strong> my_binom2 that represents the same distribution. (Hint: The whole point of this problem is to build up an object that behaves that same as the one produced by st.binom in (1) <I>without relying on st.binom at all.</I> You need to determine your own c and p vectors.) </li>
            <li> Print the probability that you roll a 4, 5, or 6 an even number of times out of the 20 rolls. Do this calculation using my_binom1 and then again using my_binom2 with the .pmf() function.
            Do your calculations agree?</li>
        </ol>
    </body>
</html>

```python
########Student Answer##############
#1
#### Method 1: use the st.binom object #####
n=20
p=1./2
my_binom1=st.binom(n,p)



#2
###### Method 2: custom the values and corresponding probabilities of the rv ######

p_values = []

for k in range(0,n+1):
    probability = nchoosek(n,k) * (p**k) * ((1-p)**(n-k))
    p_values.append(probability)
my_binom2 = st.rv_discrete(values=(range(0,n+1), p_values))
print(my_binom2.rvs(size=10))
def factorial(n):
    
    # Input: integer n 
    # Output: n!

    assert n>=0
    fact=1
    for i in range(1,n+1):
        fact=fact*i

    return fact
def nchoosek(n,k):
    # Input: integer n, integer k, where 0 <= k <= n.
    # Output: the number of ways to choose k balls from n distinct balls.
    return factorial(n)/(factorial(n-k)*factorial(k))




#3
### Final Check
probability_sum1 = 0
probability_sum2 = 0

for k in range(0, n + 1, 2):
    probability_sum1 += my_binom1.pmf(k) 
    probability_sum2 += my_binom2.pmf(k) 

print(f"my_binom1's even numbers' probability: {probability_sum1}")
print(f"my_binom2's even numbers' probability: {probability_sum2}")

if np.isclose(probability_sum1, probability_sum2):
    print("Same")
else:
    print("Different")
```



#### 2.Geometry Distribution
<br><br>**<SPAN style="BACKGROUND-COLOR: #C0C0C0">Problem 2:</SPAN>**
An engineer is testing a new type of CPU chip. According to manufacturing standards, the probability that any given chip is defective is `p = 0.5`. The engineer will continue to test new chips until the first defective one is found.

1.  What is the probability that the engineer finds the first defective chip on the 6th test?
2.  On average, how many chips should the engineer expect to test to find the first defective one?
3.  What is the probability that the first defective chip is found within the first 10 tests (inclusive)?


```python
p=0.5
n=2
cpu_standard=st.geom(p)
print(cpu_standard.pmf(n))

#2
print(cpu_standard.mean())

#3
print(cpu_standard.cdf(10))

```
#### 3.Poisson Distribution
the Poisson distribution has only one single parameter $\lambda$ and a probability mass function given by: $p(k) = \frac{e^{-\lambda}\lambda^k}{k!}$ for $k\geq 0.$ The parameter $\lambda$ represents a mean such as the number of hits of a website in one minute, or the number of mispelled words in a document. Thus $p(k)$ represents the probability the number of events occuring is $k$ given that the average number events that occur is $\lambda$.(==$P(k)$可以通俗的认为就是在一时间里来公交车的概率，例如告诉每一小时有两辆大巴，那么如果把1个小时当作单位，那么$\lambda=2$==，所以公式也可以看作是$P_t(k)= \frac{e^{-\lambda t}(\lambda t) ^k}{k!}$) 当 $n$ is large, $p$ is small, and $np \approx \lambda$.

##### Example 
]泊松分布被广泛使用，因为它在 $n$ 较大、$p$ 较小且 $np \approx \lambda$ 的情况下是二项分布的良好近似。它比二项分布更简单，只有一个参数，且不涉及二项式系数。假设你创建了一个网站，==平均每天的访问次数为 1200 次==。这可以看作是一个泊松分布的情况，其中==λ = 1200==，但我们也可以将其建模为二项分布。如果我们将一天细分为每一分钟的单位，那么在任何特定的一分钟内发生一次击中的概率为 ==$p = \frac{1200}{24*60} = \frac{5}{6}$==，而一天中有 $n = 24*60 = 1440$ 分钟。下面是这个泊松分布的二项式近似图。

```python
lamb =1200 #Average number of hits per day
n = 60*24. #Number of minutes in a day
p = lamb/n #Probability of a hit occuring in a minute
print ('p =', p)

k = range(2*lamb)
plt.plot(k,st.binom.pmf(k,n,p), 'b', label = 'Binomial')
plt.plot(k,st.poisson.pmf(k,lamb), 'r', label = 'Poisson')
plt.title('PMF of Hits Per Day')
plt.legend()

x = np.linspace(0,2*lamb,10000)
plt.figure()
plt.plot(x,st.binom.cdf(x,n,p), 'b', label = 'Binomial')
plt.plot(x,st.poisson.cdf(x,lamb), 'r', label = 'Poisson')
plt.ylim(0,1.2)
plt.title('CDF of Hits Per Day')
plt.legend()
```
The output:

![My page](assets/imgs/output.png)
![My page](assets/imgs/output1.png)


**<SPAN style="BACKGROUND-COLOR: #C0C0C0">Problem 3:</SPAN>** While working on a new research project, I have a probability of 𝑝=.017 of successfully analyzing a dataset during any given minute. Suppose there are 340 datasets that need to be analyzed, and I have 10 weeks to complete the project (assuming I work 35 hours per week). What's the probability that I will complete the project before the deadline? Equivalently, what is the probability that I analyze at least 340 datasets? To answer this question, do the following:
<html>
    <body>
        <ol>
            <li> Create a binomial variable X to represent the number of datasets I analyze (for this and other parts of the
            problem, assume I keep working at the same rate if I finish analyzing 340 datasets).</li>
            <li> Create a Poisson variable Y to represent the same number, using the Poisson approximation.
            Make sure to print out what $\lambda$ is.</li>
            <li> Find the probability of my success (i.e. analyzing at least 340 datasets) using the CDFs of each RV. Do they agree?</li>
            <li> Find the probability that I analyze exactly 340 datasets using the pmf of each RV.  Do they agree? </li>
        </ol>
    </body>
</html>

```python
#1
n=35*10*60
p=0.017
X = st.binom(n,p)

#2
lambd=n*p
Y = st.poisson(lambd)
print("lambda=",lambd)


#3
print(f"X is {1-X.cdf(339)}")
print(f"Y is {1-Y.cdf(339)}")
print("They agree")

#4
print(f"X is {X.pmf(340)}")
print(f"Y is {Y.pmf(340)}")
print("They  agree")
```
output
```shell
lambda= 357.0
X is 0.8246311033298527
Y is 0.8225239027696181
They agree
X is 0.01435241251396396
Y is 0.01433572475685986
They agree
```
### 总结
三个discrete分布的应用

# Quiz 💯

## Quiz 1
考察了什么是sample space, A.intersection(B) , 其余都是ECE313的很基础内容




